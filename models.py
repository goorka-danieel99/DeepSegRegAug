# -*- coding: utf-8 -*-
"""models.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16ljdp5Rd8G1C2iI88WKlYk7Bo49QA7qL
"""

# from torch.nn import Module, Sequential
# from torch.nn import Conv3d, ConvTranspose3d, BatchNorm3d, MaxPool3d, AvgPool1d, Dropout3d, GroupNorm
# from torch.nn import ReLU, Sigmoid
import torch
import torch.nn as nn

class SegModel(nn.Module):
  def __init__(self, in_channels=1, out_channels=2, operation='seg'):
    super().__init__()

    self.convolution1 = Convolution(in_channels, 64)
    self.convolution2 = Convolution(64, 128)
    self.convolution3 = Convolution(128, 256)
    self.convolution4 = Convolution(256, 512)
    self.convolution5 = Convolution(512, 1024)
    self.convolution6 = Convolution(1024, 512)
    self.convolution7 = Convolution(512, 256)
    self.convolution8 = Convolution(256, 128)
    self.convolution9 = Convolution(128, 64)

    self.pool = nn.MaxPool3d((2, 2, 2))

    self.deconvolution1 = Deconvolution(1024, 512)
    self.deconvolution2 = Deconvolution(512, 256)
    self.deconvolution3 = Deconvolution(256, 128)
    self.deconvolution4 = Deconvolution(128, 64)

    self.output = nn.Conv3d(64, out_channels, kernel_size=1)

  def forward(self, x):
    x1 = self.convolution1(x)
    down1 = self.pool(x1)
    x2 = self.convolution2(down1)
    down2 = self.pool(x2)
    x3 = self.convolution3(down2)
    down3 = self.pool(x3)
    x4 = self.convolution4(down3)
    down4 = self.pool(x4)
    x5 = self.convolution5(down4)

    up1 = self.convolution6(torch.cat([self.deconvolution1(x5), x4], dim=1))
    up2 = self.convolution7(torch.cat([self.deconvolution2(up1), x3], dim=1))
    up3 = self.convolution8(torch.cat([self.deconvolution3(up2), x2], dim=1))
    up4 = self.convolution9(torch.cat([self.deconvolution4(up3), x1], dim=1))

    seg = self.output(up4)

    return seg

class RegModel(nn.Module):
  def __init__(self, in_channels=1, out_channels=3, operation='reg'):
    super().__init__()

    self.convolution1 = Convolution(in_channels, 64)
    self.convolution2 = Convolution(64, 128)
    self.convolution3 = Convolution(128, 256)
    self.convolution4 = Convolution(256, 512)
    self.convolution5 = Convolution(512, 1024)
    self.convolution6 = Convolution(1024, 512)
    self.convolution7 = Convolution(512, 256)
    self.convolution8 = Convolution(256, 128)
    self.convolution9 = Convolution(128, 64)

    self.pool = nn.MaxPool3d((2, 2, 2))

    self.deconvolution1 = Deconvolution(1024, 512)
    self.deconvolution2 = Deconvolution(512, 256)
    self.deconvolution3 = Deconvolution(256, 128)
    self.deconvolution4 = Deconvolution(128, 64)

    self.output = nn.Conv3d(64, out_channels, kernel_size=1)

  def forward(self, x):
    x1 = self.convolution1(x)
    down1 = self.pool(x1)
    x2 = self.convolution2(down1)
    down2 = self.pool(x2)
    x3 = self.convolution3(down2)
    down3 = self.pool(x3)
    x4 = self.convolution4(down3)
    down4 = self.pool(x4)
    x5 = self.convolution5(down4)

    up1 = self.convolution6(torch.cat([self.deconvolution1(x5), x4], dim=1))
    up2 = self.convolution7(torch.cat([self.deconvolution2(up1), x3], dim=1))
    up3 = self.convolution8(torch.cat([self.deconvolution3(up2), x2], dim=1))
    up4 = self.convolution9(torch.cat([self.deconvolution4(up3), x1], dim=1))

    reg = self.output(up4)

    return reg

class Encoder(nn.Module):
  def __init__(self, in_channels, operation='reg'):
    super().__init__()

    self.convolution1 = Convolution(in_channels, 64)
    self.convolution2 = Convolution(64, 128)
    self.convolution3 = Convolution(128, 256)
    self.convolution4 = Convolution(256, 512)
    self.convolution5 = Convolution(512, 1024)

    self.pool = nn.MaxPool3d((2, 2, 2))

  def forward(self, input):
    x1 = self.convolution1(input)
    down1 = self.pool(x1)
    x2 = self.convolution2(down1)
    down2 = self.pool(x2)
    x3 = self.convolution3(down2)
    down3 = self.pool(x3)
    x4 = self.convolution4(down3)
    down4 = self.pool(x4)
    x5 = self.convolution5(down4)


    enc_layers = [x1, x2, x3, x4, x5]

    return  x5, enc_layers


class Decoder(nn.Module):
  def __init__(self, out_channels, operation='reg'):
    super().__init__()

    self.convolution6 = Convolution(1024, 512)
    self.convolution7 = Convolution(512, 256)
    self.convolution8 = Convolution(256, 128)
    self.convolution9 = Convolution(128, 64)

    self.deconvolution1 = Deconvolution(1024, 512)
    self.deconvolution2 = Deconvolution(512, 256)
    self.deconvolution3 = Deconvolution(256, 128)
    self.deconvolution4 = Deconvolution(128, 64)

    self.output = nn.Conv3d(64, out_channels, kernel_size=1)

  def forward(self, input, enc_layers):

    x5 = enc_layers[4]
    x4 = enc_layers[3]
    x3 = enc_layers[2]
    x2 = enc_layers[1]
    x1 = enc_layers[0]

    up1 = self.convolution6(torch.cat([self.deconvolution1(x5), x4], dim=1))
    up2 = self.convolution7(torch.cat([self.deconvolution2(up1), x3], dim=1))
    up3 = self.convolution8(torch.cat([self.deconvolution3(up2), x2], dim=1))
    up4 = self.convolution9(torch.cat([self.deconvolution4(up3), x1], dim=1))

    segreg = self.output(up4)

    return segreg

class RegSegModel(nn.Module):
  def __init__(self, in_channels=1, out_channels=2, operation='reg'):
    super().__init__()

    self.encoder = Encoder(in_channels=2)
    
    self.segmentation = Decoder(out_channels=4)
    self.registration = Decoder(out_channels=3)


  def forward(self, input1, input2):
    enc, enc_layers = self.encoder(torch.cat((input1, input2), dim=1))

    seg = self.segmentation(enc, enc_layers)
    reg = self.registration(enc, enc_layers).permute(0,2,3,4,1)

    return seg, reg

class Convolution(nn.Module):
    def __init__(self, input, output, kernel_size=3, stride=1, padding=1, operation='seg'):

        super().__init__()


        if operation == 'seg':
          self.convolution1 = nn.Sequential(
              nn.Conv3d(input, output, kernel_size=3, stride=1, padding=1),
              nn.GroupNorm(output, output),
              nn.ReLU())

          self.convolution2 = nn.Sequential(
              nn.Conv3d(output, output, kernel_size=3, stride=1, padding=1),
              nn.GroupNorm(output, output),
              nn.ReLU())
          
        if operation == 'reg':
          self.convolution1 = nn.Sequential(
              nn.Conv3d(input, output, kernel_size=3, stride=1, padding=1),
              nn.BatchNorm3d(out_feat),
              nn.ReLU())

          self.convolution2 = nn.Sequential(
              nn.Conv3d(output, output, kernel_size=3, stride=1, padding=1),
              nn.BatchNorm3d(out_feat),
              nn.ReLU())

        self.upsampler = nn.Conv3d(input, output, kernel_size=1)

    def forward(self, x):
        return self.convolution2(self.convolution1(x) + self.upsampler(x))


class Deconvolution(nn.Module):
    def __init__(self, input, output, kernel_size=3, stride=2, padding=1, operation='seg'):
        super().__init__()

        if operation == 'seg':
          self.deconvolution = nn.Sequential(
              nn.ConvTranspose3d(input, output, kernel_size=(kernel_size, kernel_size, kernel_size), stride=(stride, stride, stride), padding=(padding, padding, padding), output_padding=1),
              nn.GroupNorm(output, output),
              nn.ReLU())

        if operation == 'reg':
          self.deconvolution = nn.Sequential(
              nn.ConvTranspose3d(input, output, kernel_size=(kernel_size, kernel_size, kernel_size), stride=(stride, stride, stride), padding=(padding, padding, padding), output_padding=1),
              nn.BatchNorm3d(out_feat),
              nn.ReLU())

    def forward(self, x):
        return self.deconvolution(x)